#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
    echo "usage: $(basename "$0") <file1.c> [file2.c ...]" >&2
    exit 1
fi

mkdir -p build

interpreter_c="build/urb.c"
urb_names_h="build/dictionary.h"
tmp_c=$(mktemp)

declare -a funcs=()

# captura funções como:
#   void nome ( List * stack )
#   void nome(List* x)
regex='void[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\([^)]*List[[:space:]]*\*?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\)'

for file in "$@"; do
    cat "$file" >> "$tmp_c"
    echo "" >> "$tmp_c"

    while IFS= read -r line; do
        name=$(echo "$line" | sed -E 's/.*void[[:space:]]+([A-Za-z_][A-Za-z0-9_]*).*/\1/')
        # remove prefixo "urb_" apenas para registro
        reg_name=${name#urb_}
        funcs+=("$reg_name:$name")
    done < <(grep -Poz "$regex" "$file" | tr '\0' '\n' || true)
done

# gera urb.c
{
    echo "typedef struct List List;"
    echo "typedef union Value Value;"
    echo "typedef void (*Function)(List *stack);"
    echo
    for f in "${funcs[@]}"; do
        real_name="${f##*:}"
        echo "void $real_name(List* stack);"
    done
    echo
    echo "#define INIT_URB(context) \\"
    for f in "${funcs[@]}"; do
        real_name="${f##*:}"
        echo "    urb_push(context, (Value){.p = $real_name}); \\"
    done
    echo "    ((void)0)"
    echo
    cat "$tmp_c"
    echo
} > "$interpreter_c"

# gera urb_names.h com opcodes.h no início
{
    # concatena opcodes.h
    echo
    echo "#ifndef URB_DICTIONARY_H"
    echo "#define URB_DICTIONARY_H"
    echo
    source scripts/opcodes.sh
    index=0
    for f in "${funcs[@]}"; do
        reg_name="${f%%:*}"
        echo "#define $reg_name $index"
        index=$((index + 1))
    done
    echo
    echo "#endif // URB_DICTIONARY_H"
} > "$urb_names_h"

rm -f "$tmp_c"
