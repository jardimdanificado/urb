#!/usr/bin/env bash
set -euo pipefail

if [[ $# -lt 1 ]]; then
    echo "usage: $(basename "$0") <file1.c> [file2.c ...]" >&2
    exit 1
fi

mkdir -p build

interpreter_c="build/urb.c"
tmp_c=$(mktemp)

declare -a funcs=()

# capture functions like:
#   void nome ( List * stack )
#   void nome(List* x)
regex='void[[:space:]]+[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\([^)]*List[[:space:]]*\*?[[:space:]]*[A-Za-z_][A-Za-z0-9_]*[[:space:]]*\)'

for file in "$@"; do
    cat "$file" >> "$tmp_c"
    echo "" >> "$tmp_c"

    while IFS= read -r line; do
        name=$(echo "$line" | sed -E 's/.*void[[:space:]]+([A-Za-z_][A-Za-z0-9_]*).*/\1/')
        # remove prefixo "urb_" apenas para registro
        reg_name=${name#urb_}
        funcs+=("$reg_name:$name")
    done < <(grep -Poz "$regex" "$file" | tr '\0' '\n' || true)

done

{
    echo "typedef struct List List;"
    echo "typedef union Value Value;"
    echo "typedef void (*Function)(List *stack);"
    echo
    echo "static const char *urb_function_names[] = {"
    for f in "${funcs[@]}"; do
        reg_name="${f%%:*}"
        echo "    \"$reg_name\","
    done
    echo "    0"
    echo "};"
    echo
    for f in "${funcs[@]}"; do
        real_name="${f##*:}"
        echo "void $real_name(List* stack);"
    done
    echo
    echo "#define INIT_URB(context) \\"
    for f in "${funcs[@]}"; do
        real_name="${f##*:}"
        echo "    urb_push(context, (Value){.p = $real_name}); \\"
    done
    echo "    ((void)0)"
    echo
    cat "$tmp_c"
    echo
} | cpp -I. -P -DURB_ENABLE_CLI=1 - > "$interpreter_c"

rm -f "$tmp_c"
